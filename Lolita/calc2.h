// THIS FILE IS GENERATED BY PROJ LOLITA
// DO NOT MODIFY!!!

#include "ast-include.h"
namespace eds::loli
{
	// Forward declarations
	//

	struct Literal;
	struct Expression;
	struct Statement;

	struct BoolLiteral;
	struct IntLiteral;
	struct BinaryExpr;
	struct NamedExpr;
	struct LiteralExpr;
	struct LetStmt;
	struct JumpStmt;
	struct WhileStmt;
	struct IfElseStmt;
	struct CompoundStmt;

	// Class definitions
	//

	enum BoolValue
	{
		True,
		False,
	};

	enum BinaryOp
	{
		Asterisk,
		Slash,
		Modulus,
		Plus,
		Minus,
		And,
		Or,
		Xor,
		Gt,
		GtEq,
		Ls,
		LsEq,
		Eq,
		NotEq,
		LogicAnd,
		LogicOr,
	};

	enum JumpCommand
	{
		Break,
		Continue,
	};

	struct Literal : public AstObjectBase
	{
		struct Visitor
		{
			virtual void Visit(BoolLiteral&) = 0;
			virtual void Visit(IntLiteral&) = 0;
		};

		virtual void Accept(Visitor&) = 0;
	};
	struct Expression : public AstObjectBase
	{
		struct Visitor
		{
			virtual void Visit(BinaryExpr&) = 0;
			virtual void Visit(NamedExpr&) = 0;
			virtual void Visit(LiteralExpr&) = 0;
		};

		virtual void Accept(Visitor&) = 0;
	};
	struct Statement : public AstObjectBase
	{
		struct Visitor
		{
			virtual void Visit(LetStmt&) = 0;
			virtual void Visit(JumpStmt&) = 0;
			virtual void Visit(WhileStmt&) = 0;
			virtual void Visit(IfElseStmt&) = 0;
			virtual void Visit(CompoundStmt&) = 0;
		};

		virtual void Accept(Visitor&) = 0;
	};
	struct BoolLiteral : public Literal
	{
		BoolValue content;

	public:
		void Accept(Literal::Visitor& v) override { v.Visit(*this); }
	};

	struct IntLiteral : public Literal
	{
		Token content;

	public:
		void Accept(Literal::Visitor& v) override { v.Visit(*this); }
	};

	struct BinaryExpr : public Expression
	{
		BinaryOp op;
		Expression* lhs;
		Expression* rhs;

	public:
		void Accept(Expression::Visitor& v) override { v.Visit(*this); }
	};

	struct NamedExpr : public Expression
	{
		Token id;

	public:
		void Accept(Expression::Visitor& v) override { v.Visit(*this); }
	};

	struct LiteralExpr : public Expression
	{
		Literal* content;

	public:
		void Accept(Expression::Visitor& v) override { v.Visit(*this); }
	};

	struct LetStmt : public Statement
	{
		Token name;
		Expression* value;

	public:
		void Accept(Statement::Visitor& v) override { v.Visit(*this); }
	};

	struct JumpStmt : public Statement
	{
		JumpCommand command;

	public:
		void Accept(Statement::Visitor& v) override { v.Visit(*this); }
	};

	struct WhileStmt : public Statement
	{
		Expression* pred;
		Statement* body;

	public:
		void Accept(Statement::Visitor& v) override { v.Visit(*this); }
	};

	struct IfElseStmt : public Statement
	{
		Expression* pred;
		Statement* positive;
		Statement* negative;

	public:
		void Accept(Statement::Visitor& v) override { v.Visit(*this); }
	};

	struct CompoundStmt : public Statement
	{
		AstVector<Statement*>* children;

	public:
		void Accept(Statement::Visitor& v) override { v.Visit(*this); }
	};


	// Trait definitions
	//

	class AstTrait_BoolValue : public BasicAstTrait<BoolValue> { };
	class AstTrait_BinaryOp : public BasicAstTrait<BinaryOp> { };
	class AstTrait_JumpCommand : public BasicAstTrait<JumpCommand> { };
	class AstTrait_Literal : public BasicAstTrait<Literal> { };
	class AstTrait_Expression : public BasicAstTrait<Expression> { };
	class AstTrait_Statement : public BasicAstTrait<Statement> { };
	class AstTrait_BoolLiteral : public BasicAstTrait<BoolLiteral>
	{
	public:
		void AssignField(AstItem obj, int codinal, AstItem value) override
		{
			auto p = obj.Extract<StoreType>();
			switch (codinal)
			{
			case 0:
				QuickAssignField(p->content, value);
				break;
			default: throw 0;
			}
		}
	};
	class AstTrait_IntLiteral : public BasicAstTrait<IntLiteral>
	{
	public:
		void AssignField(AstItem obj, int codinal, AstItem value) override
		{
			auto p = obj.Extract<StoreType>();
			switch (codinal)
			{
			case 0:
				QuickAssignField(p->content, value);
				break;
			default: throw 0;
			}
		}
	};
	class AstTrait_BinaryExpr : public BasicAstTrait<BinaryExpr>
	{
	public:
		void AssignField(AstItem obj, int codinal, AstItem value) override
		{
			auto p = obj.Extract<StoreType>();
			switch (codinal)
			{
			case 0:
				QuickAssignField(p->op, value);
				break;
			case 1:
				QuickAssignField(p->lhs, value);
				break;
			case 2:
				QuickAssignField(p->rhs, value);
				break;
			default: throw 0;
			}
		}
	};
	class AstTrait_NamedExpr : public BasicAstTrait<NamedExpr>
	{
	public:
		void AssignField(AstItem obj, int codinal, AstItem value) override
		{
			auto p = obj.Extract<StoreType>();
			switch (codinal)
			{
			case 0:
				QuickAssignField(p->id, value);
				break;
			default: throw 0;
			}
		}
	};
	class AstTrait_LiteralExpr : public BasicAstTrait<LiteralExpr>
	{
	public:
		void AssignField(AstItem obj, int codinal, AstItem value) override
		{
			auto p = obj.Extract<StoreType>();
			switch (codinal)
			{
			case 0:
				QuickAssignField(p->content, value);
				break;
			default: throw 0;
			}
		}
	};
	class AstTrait_LetStmt : public BasicAstTrait<LetStmt>
	{
	public:
		void AssignField(AstItem obj, int codinal, AstItem value) override
		{
			auto p = obj.Extract<StoreType>();
			switch (codinal)
			{
			case 0:
				QuickAssignField(p->name, value);
				break;
			case 1:
				QuickAssignField(p->value, value);
				break;
			default: throw 0;
			}
		}
	};
	class AstTrait_JumpStmt : public BasicAstTrait<JumpStmt>
	{
	public:
		void AssignField(AstItem obj, int codinal, AstItem value) override
		{
			auto p = obj.Extract<StoreType>();
			switch (codinal)
			{
			case 0:
				QuickAssignField(p->command, value);
				break;
			default: throw 0;
			}
		}
	};
	class AstTrait_WhileStmt : public BasicAstTrait<WhileStmt>
	{
	public:
		void AssignField(AstItem obj, int codinal, AstItem value) override
		{
			auto p = obj.Extract<StoreType>();
			switch (codinal)
			{
			case 0:
				QuickAssignField(p->pred, value);
				break;
			case 1:
				QuickAssignField(p->body, value);
				break;
			default: throw 0;
			}
		}
	};
	class AstTrait_IfElseStmt : public BasicAstTrait<IfElseStmt>
	{
	public:
		void AssignField(AstItem obj, int codinal, AstItem value) override
		{
			auto p = obj.Extract<StoreType>();
			switch (codinal)
			{
			case 0:
				QuickAssignField(p->pred, value);
				break;
			case 1:
				QuickAssignField(p->positive, value);
				break;
			case 2:
				QuickAssignField(p->negative, value);
				break;
			default: throw 0;
			}
		}
	};
	class AstTrait_CompoundStmt : public BasicAstTrait<CompoundStmt>
	{
	public:
		void AssignField(AstItem obj, int codinal, AstItem value) override
		{
			auto p = obj.Extract<StoreType>();
			switch (codinal)
			{
			case 0:
				QuickAssignField(p->children, value);
				break;
			default: throw 0;
			}
		}
	};

	// External handle
	//

	inline std::unique_ptr<AstTraitManager> GetAstTraitManager()
	{
		auto result = std::make_unique<AstTraitManager>();

		result->Register<AstTrait_BoolValue>("BoolValue");
		result->Register<AstTrait_BinaryOp>("BinaryOp");
		result->Register<AstTrait_JumpCommand>("JumpCommand");
		result->Register<AstTrait_Literal>("Literal");
		result->Register<AstTrait_Expression>("Expression");
		result->Register<AstTrait_Statement>("Statement");
		result->Register<AstTrait_BoolLiteral>("BoolLiteral");
		result->Register<AstTrait_IntLiteral>("IntLiteral");
		result->Register<AstTrait_BinaryExpr>("BinaryExpr");
		result->Register<AstTrait_NamedExpr>("NamedExpr");
		result->Register<AstTrait_LiteralExpr>("LiteralExpr");
		result->Register<AstTrait_LetStmt>("LetStmt");
		result->Register<AstTrait_JumpStmt>("JumpStmt");
		result->Register<AstTrait_WhileStmt>("WhileStmt");
		result->Register<AstTrait_IfElseStmt>("IfElseStmt");
		result->Register<AstTrait_CompoundStmt>("CompoundStmt");

		return result;
	}
}
