// THIS FILE IS GENERATED BY PROJ. LOLITA.
// PLEASE DO NOT MODIFY!!!
//

#include "lolita-include.h"

namespace eds::loli
{

	// Forward declarations
	//

	struct Literal;
	struct Expression;
	struct Statement;

	struct BoolLiteral;
	struct IntLiteral;
	struct BinaryExpr;
	struct NamedExpr;
	struct LiteralExpr;
	struct LetStmt;
	struct JumpStmt;
	struct WhileStmt;
	struct IfElseStmt;
	struct CompoundStmt;

	// Class definitions
	//

	enum BoolValue
	{
		True,
		False,
	};
	enum BinaryOp
	{
		Asterisk,
		Slash,
		Modulus,
		Plus,
		Minus,
		And,
		Or,
		Xor,
		Gt,
		GtEq,
		Ls,
		LsEq,
		Eq,
		NotEq,
		LogicAnd,
		LogicOr,
	};
	enum JumpCommand
	{
		Break,
		Continue,
	};

	struct Literal : public AstObjectBase
	{
		struct Visitor
		{
			virtual void Visit(BoolLiteral&) = 0;
			virtual void Visit(IntLiteral&) = 0;
		};

		virtual void Accept(Visitor&) = 0;
	};
	struct Expression : public AstObjectBase
	{
		struct Visitor
		{
			virtual void Visit(BinaryExpr&) = 0;
			virtual void Visit(NamedExpr&) = 0;
			virtual void Visit(LiteralExpr&) = 0;
		};

		virtual void Accept(Visitor&) = 0;
	};
	struct Statement : public AstObjectBase
	{
		struct Visitor
		{
			virtual void Visit(LetStmt&) = 0;
			virtual void Visit(JumpStmt&) = 0;
			virtual void Visit(WhileStmt&) = 0;
			virtual void Visit(IfElseStmt&) = 0;
			virtual void Visit(CompoundStmt&) = 0;
		};

		virtual void Accept(Visitor&) = 0;
	};

	struct BoolLiteral : public Literal
	{
		BoolValue content;

	public:
		void Accept(Literal::Visitor& v) override { v.Visit(*this); }
	};
	struct IntLiteral : public Literal
	{
		Token content;

	public:
		void Accept(Literal::Visitor& v) override { v.Visit(*this); }
	};
	struct BinaryExpr : public Expression
	{
		BinaryOp op;
		Expression* lhs;
		Expression* rhs;

	public:
		void Accept(Expression::Visitor& v) override { v.Visit(*this); }
	};
	struct NamedExpr : public Expression
	{
		Token id;

	public:
		void Accept(Expression::Visitor& v) override { v.Visit(*this); }
	};
	struct LiteralExpr : public Expression
	{
		Literal* content;

	public:
		void Accept(Expression::Visitor& v) override { v.Visit(*this); }
	};
	struct LetStmt : public Statement
	{
		Token name;
		Expression* value;

	public:
		void Accept(Statement::Visitor& v) override { v.Visit(*this); }
	};
	struct JumpStmt : public Statement
	{
		JumpCommand command;

	public:
		void Accept(Statement::Visitor& v) override { v.Visit(*this); }
	};
	struct WhileStmt : public Statement
	{
		Expression* pred;
		Statement* body;

	public:
		void Accept(Statement::Visitor& v) override { v.Visit(*this); }
	};
	struct IfElseStmt : public Statement
	{
		Expression* pred;
		Statement* positive;
		Statement* negative;

	public:
		void Accept(Statement::Visitor& v) override { v.Visit(*this); }
	};
	struct CompoundStmt : public Statement
	{
		AstVector<Statement*>* children;

	public:
		void Accept(Statement::Visitor& v) override { v.Visit(*this); }
	};

	// Proxy definitions
	//

	class AstTypeProxy_BoolValue : public BasicAstTypeProxy<BoolValue> { };
	class AstTypeProxy_BinaryOp : public BasicAstTypeProxy<BinaryOp> { };
	class AstTypeProxy_JumpCommand : public BasicAstTypeProxy<JumpCommand> { };

	class AstTypeProxy_Literal : public BasicAstTypeProxy<Literal> { };
	class AstTypeProxy_Expression : public BasicAstTypeProxy<Expression> { };
	class AstTypeProxy_Statement : public BasicAstTypeProxy<Statement> { };

	class AstTypeProxy_BoolLiteral : public BasicAstTypeProxy<BoolLiteral>
	{
	public:

		void AssignField(AstTypeWrapper obj, int codinal, AstTypeWrapper value) override
		{
			auto p = obj.Extract<StoreType>();
			switch (codinal)
			{
			case 0:
				QuickAssignField(p->content, value);
				break;
			default: throw 0;
			}
		}
	};
	class AstTypeProxy_IntLiteral : public BasicAstTypeProxy<IntLiteral>
	{
	public:

		void AssignField(AstTypeWrapper obj, int codinal, AstTypeWrapper value) override
		{
			auto p = obj.Extract<StoreType>();
			switch (codinal)
			{
			case 0:
				QuickAssignField(p->content, value);
				break;
			default: throw 0;
			}
		}
	};
	class AstTypeProxy_BinaryExpr : public BasicAstTypeProxy<BinaryExpr>
	{
	public:

		void AssignField(AstTypeWrapper obj, int codinal, AstTypeWrapper value) override
		{
			auto p = obj.Extract<StoreType>();
			switch (codinal)
			{
			case 0:
				QuickAssignField(p->op, value);
				break;
			case 1:
				QuickAssignField(p->lhs, value);
				break;
			case 2:
				QuickAssignField(p->rhs, value);
				break;
			default: throw 0;
			}
		}
	};
	class AstTypeProxy_NamedExpr : public BasicAstTypeProxy<NamedExpr>
	{
	public:

		void AssignField(AstTypeWrapper obj, int codinal, AstTypeWrapper value) override
		{
			auto p = obj.Extract<StoreType>();
			switch (codinal)
			{
			case 0:
				QuickAssignField(p->id, value);
				break;
			default: throw 0;
			}
		}
	};
	class AstTypeProxy_LiteralExpr : public BasicAstTypeProxy<LiteralExpr>
	{
	public:

		void AssignField(AstTypeWrapper obj, int codinal, AstTypeWrapper value) override
		{
			auto p = obj.Extract<StoreType>();
			switch (codinal)
			{
			case 0:
				QuickAssignField(p->content, value);
				break;
			default: throw 0;
			}
		}
	};
	class AstTypeProxy_LetStmt : public BasicAstTypeProxy<LetStmt>
	{
	public:

		void AssignField(AstTypeWrapper obj, int codinal, AstTypeWrapper value) override
		{
			auto p = obj.Extract<StoreType>();
			switch (codinal)
			{
			case 0:
				QuickAssignField(p->name, value);
				break;
			case 1:
				QuickAssignField(p->value, value);
				break;
			default: throw 0;
			}
		}
	};
	class AstTypeProxy_JumpStmt : public BasicAstTypeProxy<JumpStmt>
	{
	public:

		void AssignField(AstTypeWrapper obj, int codinal, AstTypeWrapper value) override
		{
			auto p = obj.Extract<StoreType>();
			switch (codinal)
			{
			case 0:
				QuickAssignField(p->command, value);
				break;
			default: throw 0;
			}
		}
	};
	class AstTypeProxy_WhileStmt : public BasicAstTypeProxy<WhileStmt>
	{
	public:

		void AssignField(AstTypeWrapper obj, int codinal, AstTypeWrapper value) override
		{
			auto p = obj.Extract<StoreType>();
			switch (codinal)
			{
			case 0:
				QuickAssignField(p->pred, value);
				break;
			case 1:
				QuickAssignField(p->body, value);
				break;
			default: throw 0;
			}
		}
	};
	class AstTypeProxy_IfElseStmt : public BasicAstTypeProxy<IfElseStmt>
	{
	public:

		void AssignField(AstTypeWrapper obj, int codinal, AstTypeWrapper value) override
		{
			auto p = obj.Extract<StoreType>();
			switch (codinal)
			{
			case 0:
				QuickAssignField(p->pred, value);
				break;
			case 1:
				QuickAssignField(p->positive, value);
				break;
			case 2:
				QuickAssignField(p->negative, value);
				break;
			default: throw 0;
			}
		}
	};
	class AstTypeProxy_CompoundStmt : public BasicAstTypeProxy<CompoundStmt>
	{
	public:

		void AssignField(AstTypeWrapper obj, int codinal, AstTypeWrapper value) override
		{
			auto p = obj.Extract<StoreType>();
			switch (codinal)
			{
			case 0:
				QuickAssignField(p->children, value);
				break;
			default: throw 0;
			}
		}
	};

	// Proxy manager
	//

	inline std::unique_ptr<AstTypeProxyManager> CreateAstTypeProxyManager()
	{
		auto result = std::make_unique<AstTypeProxyManager>();

		result->Register<AstTypeProxy_BoolValue>("BoolValue");
		result->Register<AstTypeProxy_BinaryOp>("BinaryOp");
		result->Register<AstTypeProxy_JumpCommand>("JumpCommand");

		result->Register<AstTypeProxy_Literal>("Literal");
		result->Register<AstTypeProxy_Expression>("Expression");
		result->Register<AstTypeProxy_Statement>("Statement");

		result->Register<AstTypeProxy_BoolLiteral>("BoolLiteral");
		result->Register<AstTypeProxy_IntLiteral>("IntLiteral");
		result->Register<AstTypeProxy_BinaryExpr>("BinaryExpr");
		result->Register<AstTypeProxy_NamedExpr>("NamedExpr");
		result->Register<AstTypeProxy_LiteralExpr>("LiteralExpr");
		result->Register<AstTypeProxy_LetStmt>("LetStmt");
		result->Register<AstTypeProxy_JumpStmt>("JumpStmt");
		result->Register<AstTypeProxy_WhileStmt>("WhileStmt");
		result->Register<AstTypeProxy_IfElseStmt>("IfElseStmt");
		result->Register<AstTypeProxy_CompoundStmt>("CompoundStmt");

		return result;
	}
}
