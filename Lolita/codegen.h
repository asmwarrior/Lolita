#pragma once
#include "parsing-bootstrap.h"
#include "text\format.hpp"
#include <functional>
#include <string_view>
#include <sstream>

namespace eds::loli::codegen
{
	class CppEmitter
	{
	public:
		using CallbackType = std::function<void()>;

		// line
		//
		void EmptyLine()
		{
			buffer_ << std::endl;
		}
		void Comment(std::string_view s)
		{
			WriteIdent();
			buffer_ << "// " << s << std::endl;
		}
		void Include(std::string_view s, bool system)
		{
			WriteIdent();
			buffer_ << "#include ";
			buffer_ << (system ? '<' : '"');
			buffer_ << s;
			buffer_ << (system ? '>' : '"');
			buffer_ << std::endl;
		}

		template<typename ...TArgs>
		void WriteLine(const char* fmt, const TArgs& ...args)
		{
			WriteIdent();
			buffer_ << text::Format(fmt, args...) << std::endl;
		}

		// structure
		//

		void Namespace(std::string_view name, CallbackType cbk)
		{
			WriteStructure("namespace", name, "", false, cbk);
		}
		void Class(std::string_view name, std::string_view parent, CallbackType cbk)
		{
			WriteStructure("class", name, parent, true, cbk);
		}
		void Struct(std::string_view name, std::string_view parent, CallbackType cbk)
		{
			WriteStructure("struct", name, parent, true, cbk);
		}
		void Enum(std::string_view name, std::string_view type, CallbackType cbk)
		{
			WriteStructure("enum", name, type, true, cbk);
		}

		void Block(std::string_view header, CallbackType cbk)
		{
			WriteIdent();
			buffer_ << header << std::endl;

			WriteIdent();
			buffer_ << "{\n";

			// body
			ident_level_ += 1;
			cbk();
			ident_level_ -= 1;

			WriteIdent();
			buffer_ << "}\n";
		}

		std::string ToString()
		{
			return buffer_.str();
		}
	private:
		void WriteIdent()
		{
			for (int i = 0; i < ident_level_; ++i)
				buffer_ << "    ";
		}

		void WriteStructure(std::string_view type, std::string_view name, std::string_view parent, bool semi, CallbackType cbk)
		{
			// class decl
			WriteIdent();
			buffer_ << type << " " << name;

			if (!parent.empty())
				buffer_ << " : " << parent;

			buffer_ << std::endl;

			// openning brace
			WriteIdent();
			buffer_ << "{\n";

			// body
			ident_level_ += 1;
			cbk();
			ident_level_ -= 1;

			// closing brace
			WriteIdent();
			buffer_ << (semi ? "};\n" : "}\n");
		}

		int ident_level_ = 0;
		std::ostringstream buffer_;
	};

	std::string GenerateBindingCode(const ParserBootstrapInfo& info)
	{
		CppEmitter e;

		e.Comment("THIS FILE IS GENERATED BY PROJ. LOLITA.");
		e.Comment("PLEASE DO NOT MODIFY!!!");
		e.Comment("");

		e.EmptyLine();
		e.Include("lolita-include.h", false);

		e.EmptyLine();
		e.Namespace("eds::loli", [&]() {

			//====================================================
			e.EmptyLine();
			e.Comment("Forward declarations");
			e.Comment("");

			e.EmptyLine();
			for (const auto& base_def : info.Bases())
			{
				e.WriteLine("struct {};", base_def.Name());
			}

			e.EmptyLine();
			for (const auto& klass_def : info.Klasses())
			{
				e.WriteLine("struct {};", klass_def.Name());
			}

			//====================================================
			e.EmptyLine();
			e.Comment("Class definitions");
			e.Comment("");

			e.EmptyLine();
			for (const auto& enum_def : info.Enums())
			{
				e.Enum(enum_def.Name(), "", [&]() {
					for (const auto& item : enum_def.values)
					{
						e.WriteLine("{},", item);
					}
				});
			}

			e.EmptyLine();
			for (const auto& base_def : info.Bases())
			{
				e.Struct(base_def.Name(), "public AstObject", [&]() {

					// visitor
					e.Struct("Visitor", "", [&]() {
						for (auto klass_def : info.Klasses())
						{
							if (klass_def.base == &base_def)
							{
								e.WriteLine("virtual void Visit({}&) = 0;", klass_def.Name());
							}
						}
					});

					// accept
					e.EmptyLine();
					e.WriteLine("virtual void Accept(Visitor&) = 0;");
				});
			}

			e.EmptyLine();
			for (const auto& klass_def : info.Klasses())
			{
				auto inh = "public " + (klass_def.base ? klass_def.base->Name() : "AstObject");
				e.Struct(klass_def.Name(), inh, [&]() {
					for (const auto& member : klass_def.members)
					{
						auto type = member.type.type->Name();

						if (type == "token") type = "Token";

						if (member.type.IsVector())
						{
							type = text::Format("AstVector<{}>*", type);
						}
						else if (member.type.type->IsStoredByRef())
						{
							type.append("*");
						}

						e.WriteLine("{} {};", type, member.name);
					}

					if (klass_def.base)
					{
						e.EmptyLine();
						e.WriteLine("public:");
						e.WriteLine("void Accept({}::Visitor& v) override {{ v.Visit(*this); }}", klass_def.base->Name());
					}
				});
			}

			//====================================================
			e.EmptyLine();
			e.Comment("Proxy definitions");
			e.Comment("");

			e.EmptyLine();
			for (const auto& enum_def : info.Enums())
			{
				e.WriteLine("class AstTypeProxy_{0} : public BasicAstTypeProxy<{0}> {{ }};", enum_def.Name());
			}

			e.EmptyLine();
			for (const auto& base_def : info.Bases())
			{
				e.WriteLine("class AstTypeProxy_{0} : public BasicAstTypeProxy<{0}> {{ }};", base_def.Name());
			}

			e.EmptyLine();
			for (const auto& klass_def : info.Klasses())
			{
				auto proxy_name = text::Format("AstTypeProxy_{}", klass_def.Name());
				auto proxy_base = text::Format("public BasicAstTypeProxy<{}>", klass_def.Name());

				e.Class(proxy_name, proxy_base, [&]() {
					e.WriteLine("public:");

					e.EmptyLine();
					e.Block("void AssignField(AstTypeWrapper obj, int codinal, AstTypeWrapper value) override", [&]() {

						e.WriteLine("auto p = obj.Extract<StoreType>();");
						e.Block("switch(codinal)", [&]() {
							for (int i = 0; i < klass_def.members.size(); ++i)
							{
								const auto& member = klass_def.members[i];

								e.WriteLine("case {}:", i);
								e.WriteLine("    QuickAssignField(p->{}, value);", member.name);
								e.WriteLine("    break;");
							}

							e.WriteLine("default: throw 0;");
						});
					});
				});
			}

			//====================================================
			e.EmptyLine();
			e.Comment("Proxy manager");
			e.Comment("");

			e.EmptyLine();
			e.Block("inline std::unique_ptr<AstTypeProxyManager> CreateAstTypeProxyManager()", [&]() {
				e.WriteLine("auto result = std::make_unique<AstTypeProxyManager>();");

				e.EmptyLine();
				for (const auto& enum_def : info.Enums())
				{
					e.WriteLine("result->Register<AstTypeProxy_{0}>(\"{0}\");", enum_def.Name());
				}
				e.EmptyLine();
				for (const auto& base_def : info.Bases())
				{
					e.WriteLine("result->Register<AstTypeProxy_{0}>(\"{0}\");", base_def.Name());
				}
				e.EmptyLine();
				for (const auto& klass_def : info.Klasses())
				{
					e.WriteLine("result->Register<AstTypeProxy_{0}>(\"{0}\");", klass_def.Name());
				}

				e.EmptyLine();
				e.WriteLine("return result;");
			});
		});

		return e.ToString();
	}
}